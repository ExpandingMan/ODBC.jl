<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · ODBC.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>ODBC.jl</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/JuliaDB/ODBC.jl/tree/cb61c6fa5e31cdc9b627b54f7ac6bd6515fad10b/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="ODBC.jl-1" href="#ODBC.jl-1">ODBC.jl</a></h1><p>The <code>ODBC.jl</code> package provides high-level julia functionality over the low-level ODBC API middleware. In particular, the package allows making connections with any database that has a valid ODBC driver, sending SQL queries to those databases, and streaming the results into a variety of data sinks.</p><h3><a class="nav-anchor" id="ODBC.listdsns()-1" href="#ODBC.listdsns()-1"><code>ODBC.listdsns()</code></a></h3><p>Lists pre-configured DSN datasources available to the user. Note that DSNs are &quot;bit-specific&quot;, meaning a 32-bit DSN setup with the 32-bit ODBC system admin console will only be accessible through 32-bit julia.</p><h3><a class="nav-anchor" id="ODBC.listdrivers-1" href="#ODBC.listdrivers-1"><code>ODBC.listdrivers</code></a></h3><p>Lists valid ODBC drivers on the system which can be used manually in connection strings in the form of <code>Driver={ODBC Driver Name};</code> as a key-value pair. Valid drivers are read from the system ODBC library, which can be seen by calling <code>ODBC.API.odbc_dm</code>. This library is &quot;detected&quot; automatically when the ODBC.jl package is loaded, but can also be set by calling <code>ODBC.API.setODBC(&quot;manual_odbc_lib&quot;)</code>.</p><h3><a class="nav-anchor" id="ODBC.DSN-1" href="#ODBC.DSN-1"><code>ODBC.DSN</code></a></h3><p>Constructors:</p><p><code>ODBC.DSN(dsn, username, password) =&gt; ODBC.DSN</code></p><p><code>ODBC.DSN(connection_string; prompt::Bool=true) =&gt; ODBC.DSN</code></p><p><code>ODBC.disconnect!(dsn::ODBC.DSN)</code></p><p>The first method attempts to connect to a pre-defined DSN that has been pre-configured through your system&#39;s ODBC admin console. Settings such as the ODBC driver, server address, port #, etc. are already configured, so all that is required is the username and password to connect.</p><p>The second method takes a full connection string. Connection strings are vendor-specific, but follow the format of <code>key1=value1;key2=value2...</code> for various key-value pairs, typically including <code>Driver=X</code> and <code>Server=Y</code>. For help in figuring out how to build the right connection string for your system, see <a href="https://www.connectionstrings.com/">connectionstrings.com</a>. There is also a <code>prompt</code> keyword argument that indicates whether a driver-specific UI window should be shown if there are missing connection string key-value pairs needed for connection. If being run non-interactively, set <code>prompt=false</code>.</p><p><code>ODBC.disconnect!(dsn)</code> can also be used to disconnect.</p><h3><a class="nav-anchor" id="ODBC.query-1" href="#ODBC.query-1"><code>ODBC.query</code></a></h3><p>Methods:</p><p><code>ODBC.query(dsn::ODBC.DSN, sql::AbstractString, sink=DataFrame, args...; weakrefstrings::Bool=true, append::Bool=false)</code></p><p><code>ODBC.query{T}(dsn::DSN, sql::AbstractString, sink::T; weakrefstrings::Bool=true, append::Bool=false)</code></p><p><code>ODBC.query(source::ODBC.Source, sink=DataFrame, args...; append::Bool=false)</code></p><p><code>ODBC.query{T}(source::ODBC.Source, sink::T; append::Bool=false)</code></p><p><code>ODBC.query</code> is a high-level method for sending an SQL statement to a system and returning the results. As is shown, a valid <code>dsn::ODBC.DSN</code> and SQL statement <code>sql</code> combo can be sent, as well as an already-constructed <code>source::ODBC.Source</code>. By default, the results will be returned in a <a href="http://juliastats.github.io/DataFrames.jl/latest/"><code>DataFrame</code></a>, but a variety of options exist for returning results, including <code>CSV.Sink</code>, <code>SQLite.Sink</code>, or <code>Feather.Sink</code>. <code>ODBC.query</code> actually utilizes the <code>DataStreams.jl</code> framework, so any valid <a href="http://juliadata.github.io/DataStreams.jl/latest/#datasink-interface"><code>Data.Sink</code></a> can be used to return results. The <code>append=false</code> keyword specifies whether the results should be <em>added to</em> any existing data in the <code>Data.Sink</code>, or if the resultset should fully replace any existing data. The <code>weakrefstrings</code> argument indicates whether <code>WeakRefString</code>s should be used by default for efficiency.</p><p>Examples:</p><pre><code class="language-julia">dsn = ODBC.DSN(valid_dsn)

# return result as a DataFrame
df = ODBC.query(dsn, &quot;select * from cool_table&quot;)

# return result as a csv file
using CSV
csv = ODBC.query(dsn, &quot;select * from cool_table&quot;, CSV.Sink, &quot;cool_table.csv&quot;)

# return the result directly into a local SQLite table
using SQLite
db = SQLite.DB()

sqlite = ODBC.query(dsn, &quot;select * from cool_table&quot;, SQLite.Sink, db, &quot;cool_table_in_sqlite&quot;)

# return the result as a feather-formatted binary file
using Feather
feather = ODBC.query(dsn, &quot;select * from cool_table&quot;, Feather.Sink, &quot;cool_table.feather&quot;)
</code></pre><h3><a class="nav-anchor" id="ODBC.load-1" href="#ODBC.load-1"><code>ODBC.load</code></a></h3><p>Methods: <code>ODBC.load{T}(dsn::DSN, table::AbstractString, ::Type{T}, args...; append::Bool=false)</code></p><p><code>ODBC.load(dsn::DSN, table::AbstractString, source; append::Bool=false)</code></p><p><code>ODBC.load{T}(sink::Sink, ::Type{T}, args...; append::Bool=false)</code></p><p><code>ODBC.load(sink::Sink, source; append::Bool=false)</code></p><p><code>ODBC.load</code> is a sister method to <code>ODBC.query</code>, but instead of providing a robust way of <em>returning</em> results, it allows one to <em>send</em> data to a DB.</p><p><strong>Please note this is currently experimental and ODBC driver-dependent; meaning, an ODBC driver must impelement certain low-level API methods to enable this feature. This is not a limitation of ODBC.jl itself, but the ODBC driver provided by the vendor. In the case this method doesn&#39;t work for loading data, please see the documentation around prepared statements.</strong></p><p><code>ODBC.load</code> takes a valid DB connection <code>dsn</code> and the name of an <em>existing</em> table <code>table</code> to which to send data. Note that on-the-fly creation of a table is not currently supported. The data to send can be any valid <a href="http://juliadata.github.io/DataStreams.jl/latest/#datasource-interface"><code>Data.Source</code></a> object, from the <code>DataStreams.jl</code> framework, including a <code>DataFrame</code>, <code>CSV.Source</code>, <code>SQLite.Source</code>, <code>Feather.Source</code>, etc.</p><p>Examples:</p><pre><code class="language-julia">dsn = ODBC.DSN(valid_dsn)

# first create a remote table
ODBC.execute!(dsn, &quot;CREATE TABLE cool_table (col1 INT, col2 FLOAT, col3 VARCHAR)&quot;)

# load data from a DataFrame into the table
df = DataFrame(col1=[1,2,3], col2=[4.0, 5.0, 6.0], col3=[&quot;hey&quot;, &quot;there&quot;, &quot;sailor&quot;])

ODBC.load(dsn, &quot;cool_table&quot;, df)

# load data from a csv file
using CSV

ODBC.load(dsn, &quot;cool_table&quot;, CSV.Source, &quot;cool_table.csv&quot;)

# load data from an SQLite table
using SQLite

ODBC.load(dsn, &quot;cool_table&quot;, SQLite.Source, &quot;select * from cool_table&quot;)

# load data from a feather-formatted binary file
using Feather

ODBC.load(dsn, &quot;cool_table&quot;, Feather.Source, &quot;cool_table.feather&quot;)
</code></pre><h3><a class="nav-anchor" id="ODBC.prepare-1" href="#ODBC.prepare-1"><code>ODBC.prepare</code></a></h3><p>Methods:</p><p><code>ODBC.prepare(dsn::ODBC.DSN, querystring::String) =&gt; ODBC.Statement</code></p><p>Prepare an SQL statement <code>querystring</code> against the DB and return it as an <code>ODBC.Statement</code>. This <code>ODBC.Statement</code> can then be executed once, or repeatedly in a more efficient manner than <code>ODBC.execute!(dsn, querystring)</code>. Prepared statements can also support parameter place-holders that can be filled in dynamically before executing; this is a common strategy for bulk-loading data or other statements that need to be bulk-executed with changing simple parameters before each execution. Consult your DB/vendor-specific SQL syntax for the exact specifications for parameters.</p><p>Examples:</p><pre><code class="language-julia"># prepare a statement with 3 parameters marked by the &#39;?&#39; character
stmt = ODBC.prepare(dsn, &quot;INSERT INTO cool_table VALUES(?, ?, ?)&quot;)

# a DataFrame with data we&#39;d like to insert into a table
df = DataFrame(col1=[1,2,3], col2=[4.0, 5.0, 6.0], col3=[&quot;hey&quot;, &quot;there&quot;, &quot;sailor&quot;])

for row = 1:size(df, 1)
    # each time we execute the `stmt`, we pass another row to be bound to the parameters
    ODBC.execute!(stmt, [df[row, x] for x = 1:size(df, 2)])
end</code></pre><h3><a class="nav-anchor" id="ODBC.execute!-1" href="#ODBC.execute!-1"><code>ODBC.execute!</code></a></h3><p>Methods:</p><p><code>ODBC.execute!(dsn::ODBC.DSN, querystring::String)</code></p><p><code>ODBC.execute!(stmt::ODBC.Statement)</code></p><p><code>ODBC.execute!(stmt::ODBC.Statement, values)</code></p><p><code>ODBC.execute!</code> provides a method for executing a statement against a DB without returning any results. Certain SQL statements known as &quot;DDL&quot; statements are used to modify objects in a DB and don&#39;t have results to return anyway. While <code>ODBC.query</code> can still be used for these types of statements, <code>ODBC.execute!</code> is much more efficient. This method is also used to execute prepared statements, as noted in the documentation for <code>ODBC.prepare</code>.</p><h3><a class="nav-anchor" id="ODBC.Source-1" href="#ODBC.Source-1"><code>ODBC.Source</code></a></h3><p>Constructors:</p><p><code>ODBC.Source(dsn::ODBC.DSN, querystring::String) =&gt; ODBC.Source</code></p><p><code>ODBC.Source</code> is an implementation of a <code>Data.Source</code> in the <a href="http://juliadata.github.io/DataStreams.jl/latest/#datasource-interface">DataStreams.jl</a> framework. It takes a valid DB connection <code>dsn</code> and executes a properly formatted SQL query string <code>querystring</code> and makes preparations for returning a resultset.</p><footer><hr/></footer></article></body></html>
